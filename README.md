# go-consumer
Есть источник данных, это может (быть база данных, АПИ м пр.) генерирующий последовательность данных c определенной частотой "Ч" операций/секунду, в данном примере, это функция producer, выдающая последовательно набор натуральных чисел от 1 до limit.
Есть приемник данных, проводящий сложные манипуляции с входящими данными и, к примеру, сохраняющий результат в другую базу данных, умеющий обрабатывать входящие данные с частотой "Ч"/N операциций в секунду, в данном примере это функция processor, вычисляющая квадраты входящего значения, где с помощью паузы выполнения эмулируется длительное выполнений операции.
Для эффективного выполнения задачи, требуется согласовать источник данных и приемник данных, путем параллельной обработки в потребителе, с ограничением степени параллелизма обработки в размере concurrencySize.
Таким образом потребитель при получении данных запускает не более чем concurrencySize обработчиков. 
```
                         processor
producer -> consumer ->  processor -> terminator 
                         ...
                         processor
```
terminator - выводит на экран результат, в наеш случае, суммы квадратов входящих наруальных чисел.
При возникновении ошибки обработки, требуется отменить все последующие расчеты, и вернуть ошибку.
```
package main

import (
	"errors"
	"time"
)

const (
	limit           = 1000
	concurrencySize = 5
)

func producer(limit int) chan int {
   // your code here
}

func processor(i int) (int, error) {
	if i == 10 {
		return 0, errors.New("i hate 5")
	}
	time.Sleep(5 * time.Second)
	return i * i, nil
}

func terminator(results chan int) {
  	// your code here
}

func consumer(
    // your code here
) error {
	// your code here	
}

func main() {
	// your code here  
}
```
